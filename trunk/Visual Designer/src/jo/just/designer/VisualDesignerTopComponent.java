/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package jo.just.designer;

import java.awt.Image;
import java.awt.Point;
import java.awt.datatransfer.Transferable;
import java.awt.event.ActionEvent;
import java.beans.BeanInfo;
import java.beans.PropertyVetoException;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JComponent;
import jo.just.api.BrokerAPI;
import jo.just.api.CloudletAPI;
import jo.just.api.DatacenterAPI;
import jo.just.api.HostAPI;
import jo.just.api.VMAPI;
import jo.just.node.widget.BrokerNode;
import jo.just.node.widget.CloudComputingNode;
import jo.just.node.widget.CloudletNode;
import jo.just.node.widget.DatacenterNode;
import jo.just.node.widget.HostNode;
import jo.just.node.widget.VMNode;
import jo.just.palette.CloudPalette;
import jo.just.palette.GenreNodeFactory;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;
import org.netbeans.api.settings.ConvertAsProperties;
import org.netbeans.api.visual.action.AcceptProvider;
import org.netbeans.api.visual.action.ActionFactory;
import org.netbeans.api.visual.action.ConnectorState;
import org.netbeans.api.visual.action.WidgetAction;
import org.netbeans.api.visual.vmd.VMDNodeWidget;
import org.netbeans.api.visual.vmd.VMDPinWidget;
import org.netbeans.api.visual.widget.Widget;
import org.netbeans.spi.palette.PaletteActions;
import org.netbeans.spi.palette.PaletteController;
import org.netbeans.spi.palette.PaletteFactory;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.util.Exceptions;
import org.openide.util.ImageUtilities;
import org.openide.util.Lookup;
import org.openide.util.lookup.Lookups;
import org.openide.windows.WindowManager;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(dtd = "-//jo.just.designer//VisualDesigner//EN",
autostore = false)
@TopComponent.Description(preferredID = "VisualDesignerTopComponent",
iconBase = "jo/just/designer/resources/layout_edit16.png",
persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "editor", openAtStartup = true)
@ActionID(category = "Window", id = "jo.just.designer.VisualDesignerTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(displayName = "#CTL_VisualDesignerAction",
preferredID = "VisualDesignerTopComponent")
public final class VisualDesignerTopComponent extends TopComponent {

    private static VCCDGraphScene scene = new VCCDGraphScene();
    private static CloudComputingNode cloudComputingNode;
    private WidgetAction acceptAction = ActionFactory.createAcceptAction(new PaletteTransferHandler());

    public VisualDesignerTopComponent() {
        initComponents();
        setName(NbBundle.getMessage(VisualDesignerTopComponent.class, "CTL_VisualDesignerTopComponent"));
        setToolTipText(NbBundle.getMessage(VisualDesignerTopComponent.class, "HINT_VisualDesignerTopComponent"));

        JComponent vmdScene = scene.createView();
        scene.getActions().addAction(acceptAction);
        jScrollPane1.setViewportView(vmdScene);

        Node r = new AbstractNode(Children.create(new GenreNodeFactory(), false));
        PaletteActions a = new MyPaletteActions();
        PaletteController p = PaletteFactory.createPalette(r, a);

        associateLookup(Lookups.fixed(p));

        cloudComputingNode = NodeExplorer.getDefultRootNood();
        scene.addWidgetNode(scene, cloudComputingNode);

        //        try {
//            NodeExplorer.getNodeExplorerManager().setSelectedNodes(NodeExplorer.getNodeExplorerManager().getRootContext().getChildren().getNodes());
//
//        } catch (PropertyVetoException ex) {
//            Exceptions.printStackTrace(ex);
//        }

        //        test();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables

    @Override
    public void componentOpened() {
        // TODO add custom code on component opening
    }

    @Override
    public void componentClosed() {
        // TODO add custom code on component closing
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }

    private final class PaletteTransferHandler implements AcceptProvider {

        @Override
        public ConnectorState isAcceptable(Widget widget, Point point, Transferable t) {
            if (t.isDataFlavorSupported(CloudPalette.DATA_FLAVOR)) {
//                System.err.println("isDataFlavorSupported");
                return ConnectorState.ACCEPT;
            } else {
//                System.err.println("not isDataFlavorSupported");
                return ConnectorState.REJECT;
            }

        }

        @Override
        public void accept(Widget widget, Point point, Transferable t) {

            try {
                CloudPalette transferObj = (CloudPalette) t.getTransferData(CloudPalette.DATA_FLAVOR);

                VMDNodeWidget w = null;
                switch (transferObj.getType()) {
                    case CloudPalette.AGGREGATE_SWITCH:
                        break;

                    case CloudPalette.BROKER:
                        BrokerNode bNode = new BrokerNode(new BrokerAPI());

                        VMDNodeWidget brokerWidget = (VMDNodeWidget) scene.addNode(transferObj.getTitle() + bNode.getObj().getId());
                        brokerWidget.setPreferredLocation(new Point((int) (point.x - brokerWidget.getMinimumSize().getWidth() / 2), (int) (point.y - brokerWidget.getMinimumSize().getHeight())));
                        brokerWidget.setNodeName(transferObj.getTitle() + "[" + bNode.getObj().getId() + "]");
                        brokerWidget.setNodeImage(transferObj.getIcon(BeanInfo.ICON_COLOR_16x16));

                        VMDPinWidget datacenterPinPointer = (VMDPinWidget) scene.addPin(transferObj.getTitle() + bNode.getObj().getId(), "pinDatacenters" + bNode.getObj().getId());
                        datacenterPinPointer.setPinName("Datacenters");

                        VMDPinWidget vmPinPointer = (VMDPinWidget) scene.addPin(transferObj.getTitle() + bNode.getObj().getId(), "pinVMs" + bNode.getObj().getId());
                        vmPinPointer.setPinName("VMs");

                        VMDPinWidget cloudletPinPointer = (VMDPinWidget) scene.addPin(transferObj.getTitle() + bNode.getObj().getId(), "pinCloudlets" + bNode.getObj().getId());
                        cloudletPinPointer.setPinName("Cloudlets");

                        scene.addWidgetNode(brokerWidget, bNode);
                        w = brokerWidget;

                        break;

                    case CloudPalette.CLOUDLET:
                        CloudletNode cNode = new CloudletNode(new CloudletAPI());

                        VMDNodeWidget cloudletWidget = (VMDNodeWidget) scene.addNode(transferObj.getTitle() + cNode.getObj().getId());
                        cloudletWidget.setPreferredLocation(new Point((int) (point.x - cloudletWidget.getMinimumSize().getWidth() / 2), (int) (point.y - cloudletWidget.getMinimumSize().getHeight())));
                        cloudletWidget.setNodeName(transferObj.getTitle() + "[" + cNode.getObj().getId() + "]");
                        cloudletWidget.setNodeImage(transferObj.getIcon(BeanInfo.ICON_COLOR_16x16));

                        VMDPinWidget cloudletPin = (VMDPinWidget) scene.addPin(transferObj.getTitle() + cNode.getObj().getId(), "pin" + transferObj.getTitle() + cNode.getObj().getId());
                        cloudletPin.setPinName(transferObj.getTitle());

                        scene.addWidgetNode(cloudletWidget, cNode);
                        w = cloudletWidget;

                        break;
                    case CloudPalette.CONNECTOR:
                        break;

                    case CloudPalette.DATACENTER:
                        DatacenterNode dcNode = new DatacenterNode(new DatacenterAPI());

                        VMDNodeWidget dcWidget = (VMDNodeWidget) scene.addNode(transferObj.getTitle() + dcNode.getObj().getId());
                        dcWidget.setPreferredLocation(new Point((int) (point.x - dcWidget.getMinimumSize().getWidth() / 2), (int) (point.y - dcWidget.getMinimumSize().getHeight())));
                        dcWidget.setNodeName(transferObj.getTitle() + "[" + dcNode.getObj().getId() + "]");
                        dcWidget.setNodeImage(transferObj.getIcon(BeanInfo.ICON_COLOR_16x16));

                        VMDPinWidget brokerPinPointer = (VMDPinWidget) scene.addPin(transferObj.getTitle() + dcNode.getObj().getId(), "pinBrokers" + dcNode.getObj().getId());
                        brokerPinPointer.setPinName("Brokers");

                        VMDPinWidget hostPinPointer = (VMDPinWidget) scene.addPin(transferObj.getTitle() + dcNode.getObj().getId(), "pinHosts" + dcNode.getObj().getId());
                        hostPinPointer.setPinName("Hosts");

                        scene.addWidgetNode(dcWidget, dcNode);
                        w = dcWidget;

                        break;

                    case CloudPalette.EDGE_SWITCH:
                        break;

                    case CloudPalette.HOST:
                        HostNode hNode = new HostNode(new HostAPI());

                        VMDNodeWidget hostWidget = (VMDNodeWidget) scene.addNode(transferObj.getTitle() + hNode.getObj().getId());
                        hostWidget.setPreferredLocation(new Point((int) (point.x - hostWidget.getMinimumSize().getWidth() / 2), (int) (point.y - hostWidget.getMinimumSize().getHeight())));
                        hostWidget.setNodeName(transferObj.getTitle() + "[" + hNode.getObj().getId() + "]");
                        hostWidget.setNodeImage(transferObj.getIcon(BeanInfo.ICON_COLOR_16x16));

                        VMDPinWidget hostPin = (VMDPinWidget) scene.addPin(transferObj.getTitle() + hNode.getObj().getId(), "pin" + transferObj.getTitle() + hNode.getObj().getId());
                        hostPin.setPinName(transferObj.getTitle());

                        scene.addWidgetNode(hostWidget, hNode);
                        w = hostWidget;
                        break;
                        
                    case CloudPalette.PE:
                        break;
                    
                    case CloudPalette.ROOT_SWITCH:
                        break;
                    
                    case CloudPalette.VM:
                        VMNode vmNode = new VMNode(new VMAPI());

                        VMDNodeWidget vmWidget = (VMDNodeWidget) scene.addNode(transferObj.getTitle() + vmNode.getObj().getId());
                        vmWidget.setPreferredLocation(new Point((int) (point.x - vmWidget.getMinimumSize().getWidth() / 2), (int) (point.y - vmWidget.getMinimumSize().getHeight())));
                        vmWidget.setNodeName(transferObj.getTitle() + "[" + vmNode.getObj().getId() + "]");
                        vmWidget.setNodeImage(transferObj.getIcon(BeanInfo.ICON_COLOR_16x16));

                        VMDPinWidget vmPin = (VMDPinWidget) scene.addPin(transferObj.getTitle() + vmNode.getObj().getId(), "pin" + transferObj.getTitle() + vmNode.getObj().getId());
                        vmPin.setPinName(transferObj.getTitle());

                        scene.addWidgetNode(vmWidget, vmNode);
                        w = vmWidget;
                        break;
                }

                
                //activate Node in Explorer to show Properties Sheet
                if (w != null) {
                    NodeExplorer.getNodeExplorerManager().setRootContext(scene.getNode(w));
                    TopComponent tc = WindowManager.getDefault().findTopComponent("NodeExplorerTopComponent");
                    tc.setActivatedNodes(new Node[]{scene.getNode(w)});
                    try {
                        NodeExplorer.getNodeExplorerManager().setSelectedNodes(new Node[]{scene.getNode(w)});
                    } catch (PropertyVetoException ex) {
                        Exceptions.printStackTrace(ex);
                    }
                }


                scene.validate();



            } catch (Exception e) {
                Exceptions.printStackTrace(e);

            }
        }
    }

    public Image getIcon(String path) {
        return ImageUtilities.loadImage(path);
    }

    private void test() {
        VMDNodeWidget brokerWidget = (VMDNodeWidget) scene.addNode("broker1");
        brokerWidget.setNodeName("Broker" + "[0]");
        brokerWidget.setNodeImage(getIcon("jo/just/palette/resources/broker32.png"));

        VMDPinWidget brokerPinPointer = (VMDPinWidget) scene.addPin("broker1", "b");
        brokerPinPointer.setPinName("Broker");

        DatacenterNode[] dcNode = new DatacenterNode[]{new DatacenterNode(new DatacenterAPI())};
        cloudComputingNode.getChildren().add(dcNode);

        VMDNodeWidget dcWidget = (VMDNodeWidget) scene.addNode("datacenter1");
        dcWidget.setNodeName("Datacenter[0]");
        dcWidget.setNodeImage(getIcon("jo/just/palette/resources/datacenter32.png"));

        VMDPinWidget brokerDcPinPointer = (VMDPinWidget) scene.addPin("datacenter1", "bd");
        brokerDcPinPointer.setPinName("Broker");
        VMDPinWidget hostPinPointer = (VMDPinWidget) scene.addPin("datacenter1", "hd");
        hostPinPointer.setPinName("Hosts");
        VMDPinWidget vmPinPointer = (VMDPinWidget) scene.addPin("datacenter1", "vd");
        vmPinPointer.setPinName("VMs");

        HostNode[] hNode = new HostNode[]{new HostNode(new HostAPI())};
        cloudComputingNode.getChildren().getNodeAt(0).getChildren().add(hNode);

        VMDNodeWidget hostWidget = (VMDNodeWidget) scene.addNode("host1");
        hostWidget.setNodeName("Host[0]");
        hostWidget.setNodeImage(getIcon("jo/just/palette/resources/host32.png"));

        VMDPinWidget hostPin = (VMDPinWidget) scene.addPin("host1", "h");
        hostPin.setPinName("Host");

        VMNode[] vmNode = new VMNode[]{new VMNode(new VMAPI())};
        cloudComputingNode.getChildren().getNodeAt(0).getChildren().add(vmNode);

        VMDNodeWidget vmWidget = (VMDNodeWidget) scene.addNode("vm1");
        vmWidget.setNodeName("VM[0]");
        vmWidget.setNodeImage(getIcon("jo/just/palette/resources/vm32.png"));

        VMDPinWidget vmPin = (VMDPinWidget) scene.addPin("vm1", "v");
        vmPin.setPinName("VM");


        scene.addEdge("Edge 1");
        scene.setEdgeSource("Edge 1", "b");
        scene.setEdgeTarget("Edge 1", "bd");

        scene.addEdge("Edge 2");
        scene.setEdgeSource("Edge 2", "hd");
        scene.setEdgeTarget("Edge 2", "h");

        scene.addEdge("Edge 3");
        scene.setEdgeSource("Edge 3", "vd");
        scene.setEdgeTarget("Edge 3", "v");

        scene.layoutScene();
        scene.validate();
    }

    private static final class MyPaletteActions extends PaletteActions {

        @Override
        public Action[] getImportActions() {
            System.err.println("getImportActions()");
            return new Action[]{};
        }

        @Override
        public Action[] getCustomPaletteActions() {
            System.err.println("getCustomPaletteActions()");
            return new Action[]{};
        }

        @Override
        public Action[] getCustomCategoryActions(Lookup arg0) {
            System.err.println("getCustomCategoryActions()");
            return new Action[]{};
        }

        @Override
        public Action[] getCustomItemActions(Lookup arg0) {
            System.err.println("getCustomItemActions()");
            return new Action[]{};
        }

        @Override
        public Action getPreferredAction(Lookup arg0) {
            System.err.println("getPreferredAction()");
            return new AbstractAction() {
                @Override
                public void actionPerformed(ActionEvent arg0) {
                    //When click on the palette item
//                    throw new UnsupportedOperationException("Not supported yet.");
                    System.err.println("actionPerformed()");
                    return;
                }
            };
        }
    }

    public void removeAllNode(Node node) {
        for (int i = 0; i < node.getChildren().getNodesCount(); i++) {
        }
    }

    public static VCCDGraphScene getScene() {
        return scene;
    }

    public static CloudComputingNode getRootNode() {
        return cloudComputingNode;
    }
}
